--- thinkksh.md	2021-08-21 19:07:16.642692953 +0200
+++ ../python2/thinkpython2.md	2021-08-10 01:05:19.571150617 +0200
@@ -1,26 +1,62 @@
 ```
-// $Id: thinkksh.md,v 1.7 2021/08/21 17:06:21 heiko Exp $
+// $Id: thinkpython2.md,v 1.19 2021/08/09 23:04:32 heiko Exp $
 //
-// $Log: thinkksh.md,v $
-// Revision 1.7  2021/08/21 17:06:21  heiko
-// R1D91: Modified columns per line (lynx dump: 95 cpl).
+// $Log: thinkpython2.md,v $
+// Revision 1.19  2021/08/09 23:04:32  heiko
+// R1D79: Modified columns per line (lynx dump: 95 cpl).
 //
-// Revision 1.6  2021/08/21 16:56:07  heiko
-// R1D91: Modified columns per line (lynx dump: 95 cpl).
+// Revision 1.18  2021/08/08 23:18:48  heiko
+// R1D78: Modified columns per line (lynx dump: 95 cpl).
 //
-// Revision 1.5  2021/06/17 22:58:09  heiko
-// R1D26: Added Section 1.3.4 (Experimental debugging).
+// Revision 1.17  2021/08/08 23:09:08  heiko
+// R1D78: Modified columns per line (lynx dump: 95 cpl).
 //
-// Revision 1.4  2021/06/12 21:47:53  heiko
-// R1D21: Added Section 1.3.3 (Semantic errors).
+// Revision 1.16  2021/08/08 22:15:53  heiko
+// R1D78: Modified columns per line (lynx dump: 95 cpl).
 //
-// Revision 1.3  2021/06/07 16:33:08  heiko
-// R1D16: Added Section 1.3.2 (Runtime errors).
+// Revision 1.15  2021/08/08 21:23:00  heiko
+// R1D78: Modified columns per line (lynx dump: 95 cpl).
 //
-// Revision 1.2  2021/05/31 12:13:01  heiko
-// R1D9: Finished Section 1.3 (What is debugging?).
+// Revision 1.14  2021/08/08 21:13:54  heiko
+// R1D78: Modified columns per line (lynx dump: 95 cpl).
 //
-// Revision 1.1  2021/05/29 22:00:28  heiko
+// Revision 1.13  2021/08/07 22:53:20  heiko
+// R1D77: Modified columns per line (lynx dump: 95 cpl).
+//
+// Revision 1.12  2021/08/05 00:58:40  heiko
+// R1D74: Added Section 1.4 (Formal and natural languages).
+//
+// Revision 1.11  2021/06/15 01:06:13  heiko
+// R1D23: Added Section 1.3.4 (Experimental debugging).
+//
+// Revision 1.10  2021/06/09 17:52:37  heiko
+// R1D18: Added Section 1.3.3 (Semantic errors).
+//
+// Revision 1.9  2021/06/05 17:58:14  heiko
+// R1D14: Added Section 1.3.2 (Runtime errors).
+//
+// Revision 1.8  2021/06/04 21:59:09  heiko
+// R1D13: Modified the structure of Section 1.3.1 (Syntax errors).
+//
+// Revision 1.7  2021/06/02 20:22:52  heiko
+// R1D11: Modified the alt attributes of two images.
+//
+// Revision 1.6  2021/06/01 06:54:26  heiko
+// R1D10: Finished Section 1.4 (Formal and natural languages).
+//
+// Revision 1.5  2021/05/30 14:04:29  heiko
+// R1D8: Finished Section 1.3 (What is debugging?).
+//
+// Revision 1.4  2021/05/28 12:07:58  heiko
+// R1D6: Added Section 1.3.1 (Syntax errors).
+//
+// Revision 1.3  2021/05/26 18:12:08  heiko
+// R1D4: Finished Section 1.2 (What is a program?).
+//
+// Revision 1.2  2021/05/23 19:11:26  heiko
+// R1D1: Finished Section 1.1 (The Python programming language).
+//
+// Revision 1.1  2021/05/23 16:07:38  heiko
 // Initial revision
 //
 ```
@@ -29,9 +65,8 @@
 
 [\#100DaysOfLinux](https://twitter.com/hashtag/100DaysOfLinux) :: ROUND 1 DAY 1--100
 
-**Markdown Version of "Think KSH"**
+**Markdown Version of "Think Python First Edition"**
 
-Adapted from Allen B. Downey's "Think Python First Edition".
 Think Python First Edition is available at https://greenteapress.com/wp/think-python/.
 Styled HTML generated by [Dillinger](https://dillinger.io).
 
@@ -40,13 +75,12 @@
 
 
 
-# Think KSH: How to Think Like a Computer Scientist
+# Think Python: How to Think Like a Computer Scientist
 
-**Heiko Blomenkamp**
-First Edition (which uses KSH 93u+), Version 2.0.21
+**Allen B. Downey**
+First Edition (which uses Python 2), Version 2.0.17
 
-Think Python First Edition: Copyright (C) 2017 Allen B. Downey.
-Modifications (Think KSH): Copyright (C) 2021 Heiko Blomenkamp.
+Copyright (C) 2017 Allen B. Downey.
 
 Permission is granted to copy, distribute, and/or modify this work under the terms of
 the Creative Commons Attribution-NonCommercial 3.0 Unported License, which is
@@ -56,7 +90,7 @@
 
 - [Preface](#Preface)
 - [The way of the program](#1_The_way_of_the_program)
-    - [The KSH programming language](#11_The_KSH_programming_language)
+    - [The Python programming language](#11_The_Python_programming_language)
     - [What is a program?](#12_What_is_a_program)
     - [What is debugging?](#13_What_is_debugging)
     - [Formal and natural languages](#14_Formal_and_natural_languages)
@@ -66,8 +100,7 @@
 ## Preface
 
 [postponed]
-`[PS1='ksh(${PWD##*/}):${HISTCMD}:${TMOUT}> ']`
-
+[version: python -V]
 
 
 
@@ -92,11 +125,11 @@
 
 
 
-### 1\.1 The KSH programming language
+### 1\.1 The Python programming language
 
-The programming language you will learn is KSH. KSH is an example of a
+The programming language you will learn is Python. Python is an example of a
 **high-level language**; other high-level languages you might have heard of are C, C++,
-Python, and Java.
+Perl, and Java.
 
 There are also **low-level languages**, sometimes referred to as "machine languages" or
 "assembly languages." Loosely speaking, computers can only run programs written in
@@ -138,28 +171,28 @@
 
 &#x00A0; ![From: Source Code to: Compiler to: Object Code to: Executor to: Output.](https://greenteapress.com/thinkpython/html/thinkpython002.png "Figure 1.2")
 
-KSH is considered an interpreted language because KSH programs are executed by
+Python is considered an interpreted language because Python programs are executed by
 an interpreter. There are two ways to use the interpreter: **interactive mode** and **script
-mode**. In interactive mode, you type KSH programs and the interpreter displays the
+mode**. In interactive mode, you type Python programs and the interpreter displays the
 result:
 
 ```
-ksh(93u+):1:0> echo $((1 + 1))
+>>> 1 + 1
 2
 ```
 
-The expression `ksh(93u+):1:0>` is the **prompt** the interpreter uses to indicate that it
-is ready. If you type `echo $((1 + 1))` , the interpreter replies `2` .
+The chevron, `>>>` , is the **prompt** the interpreter uses to indicate that it is ready. If
+you type `1 + 1` , the interpreter replies `2` .
 
 Alternatively, you can store code in a file and use the interpreter to execute the
-contents of the file, which is called a **script**. By convention, KSH scripts have
-names that end with `.ksh` .
+contents of the file, which is called a **script**. By convention, Python scripts have
+names that end with `.py` .
 
 To execute the script, you have to tell the interpreter the name of the file. If you
-have a script named `dinsdale.ksh` and you are working in a \*NIX command window, you
-type `ksh dinsdale.ksh` . In other development environments, the details of executing
-scripts are different. You can find instructions for your environment at the KSH
-website `http://kornshell.com` .
+have a script named `dinsdale.py` and you are working in a \*NIX command window, you type
+`python dinsdale.py` . In other development environments, the details of executing
+scripts are different. You can find instructions for your environment at the Python
+website `http://python.org` .
 
 Working in interactive mode is convenient for testing small pieces of code because you
 can type and execute them immediately. But for anything more than a few lines, you
@@ -217,14 +250,14 @@
 
 #### 1\.3\.1 Syntax errors
 
-KSH can only execute a program if the syntax is correct; otherwise, the interpreter
+Python can only execute a program if the syntax is correct; otherwise, the interpreter
 displays an error message. **Syntax** refers to the structure of a program and the rules
 about that structure. In mathematical operations, for example, parentheses have to
 come in matching pairs; so `(4 + 5) * 10` is legal, but `8)` is a **syntax error**.
 
 In English, readers can tolerate most syntax errors, which is why we can read the
-poetry of e e cummings without spewing error messages. KSH is not so forgiving.
-If there is a single syntax error anywhere in your program, KSH will display an
+poetry of e e cummings without spewing error messages. Python is not so forgiving.
+If there is a single syntax error anywhere in your program, Python will display an
 error message and quit, and you will not be able to run your program. During the first
 few weeks of your programming career, you will probably spend a lot of time tracking
 down syntax errors. As you gain experience, you will make fewer errors and find them
@@ -356,3 +389,29 @@
 that someone realized something after a period of confusion). Formal languages
 mean exactly what they say.
 
+People who grow up speaking a natural language---everyone---often have a hard time
+adjusting to formal languages. In some ways, the difference between formal and natural
+language is like the difference between poetry and prose, but more so:
+
+Poetry:
+: Words are used for their sounds as well as for their meaning, and the whole
+poem together creates an effect or emotional response. Ambiguity is not only
+common but often deliberate.
+
+Prose:
+: The literal meaning of words is more important, and the structure contributes
+more meaning. Prose is more amenable to analysis than poetry but still often
+ambiguous.
+
+Programs:
+: The meaning of a computer program is unambiguous and literal, and can be
+understood entirely by analysis of the tokens and structure.
+
+Here are some suggestions for reading programs (and other formal languages). First,
+remember that formal languages are *much more dense* than natural languages, so it takes
+longer to read them. Also, the structure is very important, so it is usually not a
+good idea to read from top to bottom, left to right. Instead, *learn to parse* the
+program in your head, identifying the tokens and interpreting the structure. Finally,
+the details matter. Small errors in *spelling* and *punctuation*, which you can get away
+with in natural languages, can make a big difference in a formal language.
+
